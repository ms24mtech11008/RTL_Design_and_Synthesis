# RTL_Design_and_Synthesis
## Table of contents
- [Day 1 - Introduction to Verilog RTL design and Synthesis](#Day-1---Introduction-to-Verilog-RTL-design-and-Synthesis)
 - [Introduction to open-source simulator iverilog](#Introduction-to-open-source-simulator-iverilog)
  - [SKY130RTL D1SK1 L1 Introduction to iverilog design test bench](#SKY130RTL-D1SK1-L1-Introduction-to-iverilog-design-test-bench)
 - [Labs using iverilog and gtkwave](#Labs-using-iverilog-and-gtkwave)
  - [SKY130RTL D1SK2 L1 Lab1 introduction to lab](#SKY130RTL-D1SK2-L1-Lab1-introduction-to-lab)
  - [SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1](#SKY130RTL-D1SK2-L2-Lab2-Introduction-iverilog-gtkwave-part1)
  - [SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2](#SKY130RTL-D1SK2-L3-Lab2-Introduction-iverilog-gtkwave-part2)
 - [Introduction to Yosys and Logic synthesis](#Introduction-to-Yosys-and-Logic-synthesis)
  - [SKY130RTL D1SK3 L1 Introduction to yosys](#SKY130RTL-D1SK3-L1-Introduction-to-yosys)
  - [SKY130RTL D1SK3 L2 introduction to logic synthesis part1](#SKY130RTL-D1SK3-L2-introduction-to-logic-synthesis-part1)
  - [SKY130RTL D1SK3 L3 introduction to logic synthesis part2](#SKY130RTL-D1SK3-L3-introduction-to-logic-synthesis-part2)
 - [Labs using Yosys and Sky130 PDKs](#Labs-using-Yosys-and-Sky130-PDKs)
  - [SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1](#SKY130RTL-D1SK4-L1-Lab3-Yosys-1-good-mux-Part1)
  - [SKY130RTL D1SK4 L2 Lab3 Yosys 1 good mux Part2](#SKY130RTL-D1SK4-L2-Lab3-Yosys-1-good-mux-Part2)
  - [SKY130RTL D1SK4 L3 Lab3 Yosys 1 good mux Part3](#SKY130RTL-D1SK4-L3-Lab3-Yosys-1-good-mux-Part3)
- [Day 2 - Timing libs, hierarchical vs flat synthesis and efficient flop coding styles](#Day-2---Timing-libs,-hierarchical-vs-flat-synthesis-and-efficient-flop-coding-styles)
 - [Introduction to timing .libs](#Introduction-to-timing-.libs)
  - [SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part1](#SKY130RTL-D2SK1-L2-Lab4-Introduction-to-dot-Lib-part1)
  - [SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2](#SKY130RTL-D2SK1-L2-Lab4-Introduction-to-dot-Lib-part2)
  - [SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part3](#SKY130RTL-D2SK1-L2-Lab4-Introduction-to-dot-Lib-part3)
 - [Hierarchical vs Flat Synthesis](#Hierarchical-vs-Flat-Synthesis)
  - [SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1](#SKY130RTL-D2SK2-L1-Lab05-Hier-synthesis-flat-synthesis-part1)
  - [SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2](#SKY130RTL-D2SK2-L2-Lab05-Hier-synthesis-flat-synthesis-part2)
  - [SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1](#SKY130RTL-D2SK3-L3-Lab-flop-synthesis-simulations-part1)
  - [SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2](#SKY130RTL-D2SK3-L4-Lab-flop-synthesis-simulations-part2)
  - 



# Day 1 - Introduction to Verilog RTL design and Synthesis
## Introduction to open-source simulator iverilog
---
### SKY130RTL D1SK1 L1 Introduction to iverilog design test bench
---

A **simulator** is a tool used to verify the behavior of a design. In RTL design, the simulator checks whether the design adheres to the specifications by applying a set of input stimuli.

In this course, we are using **Icarus Verilog (iverilog)** as the simulation tool.

### What is a Design?

A **design** is the actual Verilog code or a set of Verilog modules that implement the intended functionality to meet the required specifications.

### What is a Test Bench?

A **test bench** is the setup used to apply input stimuli (test vectors) to the design in order to verify its functionality. It provides the inputs and checks the outputs of the design during simulation.

### How Does a Simulator Work?

The simulator monitors the input signals for any changes.

* When an input changes, the simulator evaluates and updates the outputs accordingly.
* If there is no change in the inputs, the outputs remain unchanged.
  The simulator is event-driven and responds only to input value changes.

### Design and Test Bench Setup

The design contains one or more **primary inputs** and **primary outputs**.
The **test bench** includes:

* A **stimulus generator** to apply input signals to the design.
* A **stimulus observer** to monitor and verify the outputs.

All these components together form the test bench environment.

**Note:** The test bench itself does not have any primary inputs or outputs. It operates entirely within the simulation environment to drive and observe the design.

![Screenshot 2025-07-09 130655](https://github.com/user-attachments/assets/c85f95a3-6840-47e1-9fe2-c673c71d2915)

Iverilog-based simulation flow:

The design and test bench are provided as inputs to iverilog. As mentioned earlier, the simulator monitors changes in input signals and updates the output accordingly. The output generated by the simulator is a `.vcd` file, which stands for Value Change Dump format.

To view this output waveform, we use **GTKWave**.

![Screenshot 2025-07-09 132236](https://github.com/user-attachments/assets/39f77655-dfcb-4376-a798-04ee26d51e25)

---
## Labs using iverilog and gtkwave
---
### SKY130RTL D1SK2 L1 Lab1 introduction to lab
---
### Toolflow and File Setup for Labs

We will now set up the necessary toolflow and file structure to run the labs.

#### Step 1: Create a Directory

Create a directory named `VLSI` and navigate into it:

```bash
mkdir VLSI
cd VLSI
````

#### Step 2: Clone the Required Repositories

Clone the following repositories from GitHub:

* **sky130RTLDesignAndSynthesisWorkshop**

```bash
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
```

* **vsdflow**

```bash
git clone https://github.com/kunalg123/vsdflow.git
```

After this, your directory structure should look like:

```
VLSI/
├── sky130RTLDesignAndSynthesisWorkshop/
└── vsdflow/
```

This completes the initial setup required for running the labs.

![Screenshot 2025-07-09 143022](https://github.com/user-attachments/assets/e5cceec9-36a3-498b-a280-3b4e9be97b39)

![Screenshot 2025-07-09 143738](https://github.com/user-attachments/assets/9b16df58-5cf3-4465-b7b4-6700127203ad)

The contents of sky130RTLDesignAndSynthesisWorkshop directory are shown below

![Screenshot 2025-07-09 144919](https://github.com/user-attachments/assets/2f697cc0-57fc-4b92-9117-602ef47dccdd)

The `lib` directory contains the standard cell library that we will use for synthesis.
The `verilog_model` directory contains the Verilog models of all the standard cells present in the `.lib` file.

![Screenshot 2025-07-09 145308](https://github.com/user-attachments/assets/34e65092-a36f-4a94-9ced-8a46ed362db3)

![Screenshot 2025-07-09 145557](https://github.com/user-attachments/assets/915a4bdd-e194-45c5-a634-aec0d4b11516)

The `verilog_files` folder contains all our lab experiments, including both the source files and the testbench files.

![Screenshot 2025-07-09 145515](https://github.com/user-attachments/assets/e37cadf1-25dd-4c3a-8d8a-15160cb84add)

---
### SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1
---

### Tool Installation

Install the following tools required to run the labs:

#### 1. Install **Icarus Verilog** (`iverilog`)

```bash
sudo apt-get install iverilog
```

#### 2. Install **GTKWave**

```bash
sudo apt-get install gtkwave
```

These tools will allow you to compile Verilog files and visualize waveform outputs.

![Screenshot 2025-07-09 150942](https://github.com/user-attachments/assets/0f30c5ee-21e3-45c4-ba69-a85477202f3a)

![Screenshot 2025-07-09 151053](https://github.com/user-attachments/assets/0864bae3-e7c2-40e7-8456-10f02e9ac3d3)

### Simulate the Design: `good_mux`

Follow the steps below to compile, simulate, and view the waveform for the `good_mux` design.

#### 1. Compile the Design and Testbench

```bash
iverilog good_mux.v tb_good_mux.v
```

#### 2. Run the Simulation

```bash
./a.out
```

This will generate a waveform file named `tb_good_mux.vcd`.

#### 3. View the Waveform

```bash
gtkwave tb_good_mux.vcd
```

The verilog code for the design good_mux.v is shown below

![Screenshot 2025-07-09 151517](https://github.com/user-attachments/assets/aab406e3-8420-4069-9ed0-23897d87bd9d)

The verilog code for the testbench tb_good_mux.v is shown below

![Screenshot 2025-07-09 151553](https://github.com/user-attachments/assets/30be7049-31fe-4892-9a11-b4509f56c16a)

results:

![Screenshot 2025-07-09 151737](https://github.com/user-attachments/assets/8c56832a-1d8c-454c-b89b-78cada20f947)

viewing the waveform 

![Screenshot 2025-07-09 151853](https://github.com/user-attachments/assets/7b132bcf-8e75-4842-a5b1-e519a5c157d0)

![Screenshot 2025-07-09 152147](https://github.com/user-attachments/assets/d208c04a-237f-44d9-b008-9e7926d5f996)

---
### SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2
---

### 1. `good_mux.v` (Design)

```verilog
module good_mux (input i0, input i1, input sel, output reg y);

  always @(*) begin
    if (sel)
      y = i1;
    else
      y = i0;
  end

endmodule
```

### Explanation:

* **Inputs**: `i0`, `i1`, and `sel` (all 1-bit signals)
* **Output**: `y` (register type, 1-bit)
* The `always @(*)` block watches all inputs.
* If `sel = 1`, then `y = i1`; else `y = i0`.
* This is a 2:1 multiplexer.

---

## 2.`tb_good_mux.v` (Testbench)

```verilog
`timescale 1ns / 1ps

module tb_good_mux;

  // Inputs
  reg i0, i1, sel;

  // Output
  wire y;

  // Instantiate the Unit Under Test (UUT)
  good_mux uut (
    .i0(i0),
    .i1(i1),
    .sel(sel),
    .y(y)
  );

  initial begin
    $dumpfile("tb_good_mux.vcd");
    $dumpvars(0, tb_good_mux);

    // Initialize Inputs
    sel = 0;
    i0 = 0;
    i1 = 0;

    // Run simulation for 300 ns
    #300 $finish;
  end

  // Toggle sel every 75 ns
  always #75 sel = ~sel;

  // Toggle i0 every 10 ns
  always #10 i0 = ~i0;

  // Toggle i1 every 55 ns
  always #55 i1 = ~i1;

endmodule
```

---

## Testbench Behavior:

* Simulation runs for 300 ns.
* `sel` toggles every 75 ns to switch between `i0` and `i1`.
* `i0` toggles every 10 ns.
* `i1` toggles every 55 ns.
* Output `y` follows `i0` or `i1` based on the value of `sel`.
* Waveform is dumped to `tb_good_mux.vcd` and can be viewed using GTKWave.

---
## Introduction to Yosys and Logic synthesis
---
### SKY130RTL D1SK3 L1 Introduction to yosys
---

## Introduction to Yosys

**Yosys** is the synthesizer tool used in this course. It is responsible for converting RTL (Register Transfer Level) code into a gate-level **netlist** using standard cells.

### Role of Synthesizer:

A synthesizer takes a digital RTL design and a standard cell library (`.lib` file) and generates a netlist that represents the circuit using gates and cells from the library.

### Yosys Synthesis Flow:

1. **Inputs to Yosys**:

   * The RTL design (`.v` file)
   * The standard cell library (`.lib` file)

![Screenshot 2025-07-09 155007](https://github.com/user-attachments/assets/a2b57e82-b6cb-489f-a5b2-fe5d23f89cf8)


2. **Yosys Commands**:

   * `read_verilog` – Reads the Verilog design file.
   * `read_liberty` – Reads the `.lib` file containing timing and cell information.
   * `write_verilog` – Writes out the synthesized netlist.

![Screenshot 2025-07-09 155111](https://github.com/user-attachments/assets/ecfeb932-9879-41b6-958a-39ed83652fe3)

3. **Output**:

   * A netlist file representing the design using standard cells from the `.lib` library.

### Netlist Verification:

To verify if the synthesis process was successful and functionally correct:

* Use the **same testbench** that was used for the original RTL simulation.
* Apply the synthesized **netlist** and the **testbench** to the simulator (**Icarus Verilog**).
* Generate the VCD (`.vcd`) file.
* Load the VCD file in **GTKWave** and compare the waveform output.

![Screenshot 2025-07-09 155345](https://github.com/user-attachments/assets/61b6d58e-e37e-4e12-b016-1ec309d89379)

### Important Notes:

* The stimulus in the testbench **must match** the one used during RTL simulation.
* The **primary inputs and outputs** of the netlist remain the same as the RTL design.
* Therefore, **the same testbench** can be reused for post-synthesis simulation.

![Screenshot 2025-07-09 155551](https://github.com/user-attachments/assets/fae00675-36ce-46d9-a14c-be5a60da2f5d)

---
### SKY130RTL D1SK3 L2 introduction to logic synthesis part1
---

### **Logic Synthesis Overview**

#### **1. RTL Design**

* RTL (Register Transfer Level) design is the **behavioral representation** of a digital system based on its required specification.
* It defines how data moves between registers and how operations are performed on that data.

![Screenshot 2025-07-10 093911](https://github.com/user-attachments/assets/14da95b2-b608-4591-9b49-6265b82af104)

![Screenshot 2025-07-10 093941](https://github.com/user-attachments/assets/97dbaded-68ba-4c5a-a742-81c2c2251a0c)

#### **2. What is Logic Synthesis?**

* Logic synthesis is the **process of converting RTL code into a digital logic circuit**.
* This involves translating behavioral descriptions into a network of logic gates.
* The transition from RTL to gate-level design is called **synthesis**.
* The final output of this process is a **netlist**, which describes the gates and their interconnections.

#### **3. Inputs and Outputs of Synthesis**

* **Inputs:**

  * RTL Design (written in Verilog or VHDL)
  * Technology Library (`.lib` file)
* **Output:**

  * Gate-level netlist (`.v` file)

![Screenshot 2025-07-10 094007](https://github.com/user-attachments/assets/cd388e51-8760-4ff2-9dcc-bbf54b26d40c)

#### **4. What is a `.lib` File?**

* A `.lib` file is a **collection of logic cells** provided by a standard cell library.
* It includes basic gates like **AND, OR, NOT**, and their **variants**:

  * Different **input configurations** (e.g., 2-input OR, 3-input OR)
  * Different **speed-power tradeoffs** (e.g., **slow**, **medium**, **fast** cells)

![Screenshot 2025-07-10 094022](https://github.com/user-attachments/assets/a81e341a-c57e-4682-8bab-8d948ff7abf7)

#### **5. Why Different Flavours of Gates?**

* The **combinational delay** in a logic path directly affects the **maximum speed** of a digital circuit.

![Screenshot 2025-07-10 094036](https://github.com/user-attachments/assets/e0f4f50a-053c-40fc-9b0f-62439c696b37)

* The clock cycle must account for:

  ```
  Tclk > Tcq_A + Tcomb + Tsetup_B
  ```

  * **Tcq\_A** = Clock-to-Q delay of DFF A
  * **Tcomb** = Delay of the combinational logic
  * **Tsetup\_B** = Setup time of DFF B

* To **minimize Tcomb**, we use **faster cells** from the `.lib` file.

* This helps reduce the required **clock period (Tclk)** and hence **increase the operating frequency**.

#### **6. Maximum Clock Frequency**

* The **minimum clock period** determines the **maximum frequency**:

  ```
  fclk(max) = 1 / Tclk(min)
  ```

![Screenshot 2025-07-10 094117](https://github.com/user-attachments/assets/e531047d-079a-4be1-bd90-bbcd3cefbbfe)

---
### SKY130RTL D1SK3 L3 introduction to logic synthesis part2
---

### **Are Faster Cells Sufficient?**

At first glance, it might seem that using only **faster cells** is the key to achieving **maximum performance**. After all, higher clock speeds typically mean better performance. But this leads us to an important question:

> If faster cells minimize delay, **why are slower cells needed at all?**

---

### **Why Do We Need Slow Cells?**

To meet **timing constraints**, both **setup** and **hold** times must be satisfied:

* For **setup time** (performance constraint), we want the data to arrive *before* the clock edge.
* For **hold time** (reliability constraint), we want the data to **stay stable briefly after** the clock edge.

![Screenshot 2025-07-10 095024](https://github.com/user-attachments/assets/66e3dea3-ce07-4e42-b216-b52dd5cd7e4c)

If the combinational delay is **too short**, we may violate **hold time**:

```
Thold_B < Tcq_A + Tcomb
```

So:

* We need **faster cells** to **reduce Tcomb** and meet setup timing.
* We need **slower cells** to **increase Tcomb** and avoid hold time violations.

The `.lib` file includes all these different **cell variants** to allow flexibility in achieving the correct balance.

---

### **Understanding Hold Time**

* **Hold time** of a flip-flop is the **minimum time** after the clock edge during which data **must remain stable**.
* If the input to flip-flop B changes **too quickly**, it might capture the **wrong data**.
* Thus, **slower cells** can intentionally **increase delay** to help meet the hold constraint.

---

### **Faster vs. Slower Cells**

* The **load** in a digital logic circuit is essentially a **capacitance**.
* The **faster** we can **charge/discharge** this load, the **lower** the propagation delay.

| Parameter        | Faster Cells          | Slower Cells              |
| ---------------- | --------------------- | ------------------------- |
| Transistor Width | Wider (more current)  | Narrower (less current)   |
| Delay            | Lower                 | Higher                    |
| Area             | Larger                | Smaller                   |
| Power            | Higher                | Lower                     |
| Use Case         | Improves setup timing | Helps fix hold violations |

---

### **Trade-Offs: Speed vs. Area/Power**

Faster cells offer performance benefits but come at a **cost**:

* **More area**
* **More power consumption**
* **Greater risk of hold time violations**

Slower cells are:

* **Power-efficient**
* **Area-efficient**
* **Useful in preventing hold violations**

Hence, **faster cells are not always sufficient or ideal**.

---

### **Selection of Cells: Synthesizer Guidance**

The **synthesis tool** decides which cells to use during logic synthesis. However, we must **guide** it to choose an **optimal mix** of fast and slow cells.

* **Too many fast cells** → High power, large area, potential hold issues.
* **Too many slow cells** → Fails to meet timing/performance goals.

This guidance is provided using **constraints**:

* Timing constraints (clock period, setup/hold margin)
* Area and power constraints
* Design objectives and priorities

---

### **Conclusion**

The process of synthesis is not just about making the circuit work—it's about making it work **efficiently**. The selection between faster and slower cells is a **critical design decision**, and synthesis tools use **constraints** to make this trade-off in a balanced way.

![Screenshot 2025-07-10 095118](https://github.com/user-attachments/assets/02fc26c7-9db8-4d52-8278-0edab170a5ef)

---
## Labs using Yosys and Sky130 PDKs
---
### SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1
---

### **Introduction to Synthesizer: Yosys**

**Yosys** is an open-source synthesis tool used for converting RTL code into a gate-level netlist using a given standard cell library.

#### **Steps to Invoke and Use Yosys**

1. **Start Yosys**

   * Open a terminal and navigate to the working directory:

     ```bash
     cd verilog_files
     ```
   * Invoke the tool by typing:

     ```bash
     yosys
     ```

---

#### **1. Read the Standard Cell Library**

Before synthesis, the tool must understand the available logic cells. This is done by reading the `.lib` file:

```yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```

---

#### **2. Read the Verilog Design**

Next, import the RTL design (example: a multiplexer design named `good_mux.v`):

```yosys
read_verilog good_mux.v
```

![Screenshot 2025-07-10 101837](https://github.com/user-attachments/assets/ee6362bf-f4a4-479a-aebf-9e94cdc53062)

---

#### **3. Perform Synthesis**

Specify the top module of the design:

```yosys
synth -top good_mux
```
![Screenshot 2025-07-10 101929](https://github.com/user-attachments/assets/0c1476d1-7ab7-49a9-9289-118e98a896c4)

This step translates the RTL to a gate-level representation using generic gates.

![Screenshot 2025-07-10 101957](https://github.com/user-attachments/assets/50c26202-08bc-45db-8e04-508c9e3238a2)

---

#### **4. Technology Mapping**

Map the synthesized design to standard cells defined in the `.lib` file:

```yosys
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
![Screenshot 2025-07-10 102113](https://github.com/user-attachments/assets/7c8b46da-a69b-4e00-ae1f-1abdd597ce5f)

At this stage, the synthesis is complete and the result is a netlist using specific standard cells.

---

#### **5. Analyze the Output**

![Screenshot 2025-07-10 102151](https://github.com/user-attachments/assets/d2a1e221-0bfd-468e-9298-97eb9467711e)

* Compare the netlist with the original `good_mux.v`.
* **Note:**

  * The output netlist will not include internal signals.
  * Only **3 inputs** and **1 output** are visible (as in the original RTL).
  * The following **standard cells** are used:
mux2_1

---

#### **6. Visualize the Logic**

To view a graphical representation of the synthesized logic, use the `show` command:

```yosys
show
```

![Screenshot 2025-07-10 102641](https://github.com/user-attachments/assets/ac6efe5e-b198-49cc-a005-fffeb38689a3)

This launches a viewer that displays the gate-level circuit as derived from the RTL.

![Screenshot 2025-07-10 102709](https://github.com/user-attachments/assets/472d982b-6b1f-41d2-82fb-cbb8a053e5bf)

---
### SKY130RTL D1SK4 L2 Lab3 Yosys 1 good mux Part2
--- 

### **Corresponding Verilog Code**

```verilog
module good_mux (
    input i0,
    input i1,
    input sel,
    output reg y
);

always @(*) begin
    if (sel)
        y = i1;
    else
        y = i0;
end

endmodule
```

---

### **Explanation of the Yosys Output Image**

This is a graphical, gate-level representation of the `good_mux` module, generated using the `show` command in Yosys after synthesis and technology mapping using the Sky130 standard cell library.

#### **Block-by-Block Explanation**

| Element                   | Description                                                                      |
| ------------------------- | -------------------------------------------------------------------------------- |
| `i0`, `i1`, `sel`         | These are the 3 input signals to the module, shown entering on the left.         |
| `$86`                     | Internal instance name auto-generated by Yosys.                                  |
| `sky130_fd_sc_hd__mux2_1` | This is the 2:1 multiplexer standard cell from the Sky130 standard cell library. |
| `A0`, `A1`, `S`           | Input pins of the multiplexer: A0 = i0, A1 = i1, S = sel                         |
| `X`                       | Output pin of the multiplexer cell.                                              |
| `y`                       | Final output of the module, connected to the mux output.                         |
| `good_mux`                | Name of the top-level module.                                                    |

---

### **Mapping Between RTL and Synthesized Logic**

* The `always` block in the RTL uses an `if-else` condition to assign either `i0` or `i1` to `y`, based on the value of `sel`.
* During synthesis, Yosys recognized this as a 2:1 multiplexer function.
* It replaced the behavioral logic with a `sky130_fd_sc_hd__mux2_1` standard cell.
* This standard cell has three inputs: A0 (i0), A1 (i1), and S (select), and one output X which drives `y`.

---

### **Conclusion**

Yosys successfully synthesized the behavioral Verilog into a gate-level representation using the appropriate multiplexer cell from the Sky130 library. The visualization shows that the design is mapped efficiently, and internal signals are optimized out in favor of direct cell-level connections.

---
### SKY130RTL D1SK4 L3 Lab3 Yosys 1 good mux Part3
---

### **Writing the Netlist in Yosys**

Once synthesis and technology mapping are complete, you can **export the gate-level netlist** using the following command:

```yosys
write_verilog good_mux_netlist.v
```
![image](https://github.com/user-attachments/assets/aa10189c-44cc-484e-84c1-e4438ba6fa24)

This generates a netlist file named `good_mux_netlist.v`.

To create a **simplified netlist** (without attributes like timing, area, etc.), use:

```yosys
write_verilog -noattr good_mux_netlist.v
```

This version is easier to read and focuses only on structural connections.

---
![Screenshot 2025-07-10 105453](https://github.com/user-attachments/assets/892fb7cd-bff9-4558-89a0-b853789e84ea)

![Screenshot 2025-07-10 105544](https://github.com/user-attachments/assets/129a4618-5555-4f00-ac41-a49579dff863)

### **Sample Netlist: `good_mux_netlist.v`**

```verilog
module good_mux(i0, i1, sel, y);

  // Wire declarations
  wire n0;
  wire n1;
  wire n2;
  wire n3;

  // Port declarations
  input i0;
  input i1;
  input sel;
  output y;

  // Instance of standard cell mux2_1 from Sky130 library
  sky130_fd_sc_hd__mux2_1 u1 (
    .A0(n0),
    .A1(n1),
    .S(n2),
    .X(n3)
  );

  // Wire assignments
  assign n0 = i0;
  assign n1 = i1;
  assign n2 = sel;
  assign y  = n3;

endmodule
```

---

### **Explanation of Key Elements**

| Component                          | Description                                           |
| ---------------------------------- | ----------------------------------------------------- |
| `sky130_fd_sc_hd__mux2_1`          | 2:1 multiplexer standard cell from the Sky130 library |
| `u1`                               | Instance name (can be autogenerated or user-defined)  |
| `.A0(n0), .A1(n1), .S(n2), .X(n3)` | Port-to-net connections                               |
| `n0–n3`                            | Internal wires for connecting RTL ports to cell ports |

---

### **Notes**

* This netlist is **structural**, meaning it lists the components used and how they’re connected.
* It's used for **place and route**, **static timing analysis**, and further backend steps.
* The simplified netlist with `-noattr` is generally preferred for **manual inspection or debugging**.

---
# Day 2 - Timing libs, hierarchical vs flat synthesis and efficient flop coding styles
---
## Introduction to timing .libs
---
### SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part1
---

### **Understanding the Contents of a `.lib` File**

The `.lib` file, also known as a **Liberty file**, contains detailed **timing, power, and functional information** about standard cells used during synthesis. Let’s break down the key elements from a typical `.lib` file.

---

![Screenshot 2025-07-10 115849](https://github.com/user-attachments/assets/cf4ef313-c43a-465a-81d5-98ab060e4ba0)

#### **1. Library Declaration**

```
Library ("sky130_fd_sc_hd__tt_025C_1v80")
```

This line defines the **name of the library** being used.

* `sky130_fd_sc_hd`: SkyWater 130nm standard cell library (high-density variant).
* `tt`: Refers to the **PVT (Process-Voltage-Temperature) corner**, in this case, **typical process**.
* `025C`: Indicates a **temperature of 25°C**.
* `1v80`: Indicates the **supply voltage** is **1.80V**.

---

#### **2. What is a PVT Corner?**

PVT stands for **Process, Voltage, and Temperature** — three key variables that influence how silicon behaves.

| Parameter       | Meaning                                                                                                |
| --------------- | ------------------------------------------------------------------------------------------------------ |
| **Process**     | Refers to **fabrication variation** (e.g., fast, slow, typical silicon).                               |
| **Voltage**     | Varying supply voltages affect the switching speed and power.                                          |
| **Temperature** | Higher temperatures cause **slower operation**, and lower temperatures can cause **faster switching**. |

---

#### **3. Why Do We Need PVT Corners?**

Due to real-world variations during manufacturing and operating conditions, we need to ensure that our design:

* Works correctly in **worst-case**, **best-case**, and **typical** conditions.
* Is **functionally correct** and **timing-safe** under **all valid scenarios**.

Examples of PVT corners:

| Corner Name    | Description                                   |
| -------------- | --------------------------------------------- |
| `ss_125C_1v60` | Slow process, 125°C, 1.60V (worst-case delay) |
| `ff_0C_1v95`   | Fast process, 0°C, 1.95V (best-case delay)    |
| `tt_025C_1v80` | Typical case for normal operation             |

---

#### **Conclusion**

The `.lib` file acts as a **technology reference** for the synthesis tool. It helps the tool:

* Select appropriate **standard cells**.
* Estimate **timing** and **power**.
* Perform **technology mapping** based on **PVT-aware constraints**.

A proper understanding of the `.lib` content ensures that the synthesized circuit will function correctly under all expected operating conditions.

---
### SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part2
---

### **Deep Dive into the `.lib` File**

The `.lib` (Liberty) file contains **detailed information about standard cells** used during logic synthesis and static timing analysis. Let’s explore its major contents and structure.

---

![Screenshot 2025-07-10 115849](https://github.com/user-attachments/assets/0670d001-20e5-4a37-a067-d664b963a4ed)

### **1. Units and Operating Conditions**

The `.lib` file begins by defining **units** for various physical quantities:

* **Time** (e.g., in nanoseconds)
* **Voltage** (e.g., volts)
* **Power** (e.g., microwatts)
* **Current** (e.g., milliamperes)
* **Resistance**, **Capacitance**, **Capacitive load** (typically in ohms, femtofarads, etc.)

![Screenshot 2025-07-10 120836](https://github.com/user-attachments/assets/c4c8e7d5-4a7f-421e-9f67-98fa581fdca1)

It also specifies the **operating conditions** under which the cell data is valid, including:

* **Temperature**
* **Supply voltage**
* **Process corner**

These parameters help the synthesis tool evaluate the performance of each cell under different environmental and manufacturing variations.

---

### **2. Multiple Cells and Cell Definitions**

A typical `.lib` file contains **many standard cells**. Each cell begins with the keyword:

```liberty
cell (cell_name) {
   ...
}
```

For example:

```liberty
cell (sky130_fd_sc_hd__a2111o_1) {
   ...
}
```
![Screenshot 2025-07-10 120920](https://github.com/user-attachments/assets/0aff8fc7-6ea3-435b-a98b-a0cecae7a0d8)


This marks the beginning of the definition for the cell `sky130_fd_sc_hd__a2111o_1`.

---

### **3. Flavours of Cells**

* The **same logic function** may have **multiple variants** (or flavours), e.g., `_0`, `_1`, `_2`, etc.
* These variants differ in **driving strength**, **delay**, **power consumption**, and **area**.
* For example:

  * `sky130_fd_sc_hd__a2111o_1`: Standard drive
  * `sky130_fd_sc_hd__a2111o_2`: Higher drive strength

---

### **4. Example Cell: `sky130_fd_sc_hd__a2111o_1`**

* This is a complex gate with **5 inputs**: `A1`, `A2`, `B1`, `C1`, `D1`.

* The cell performs a specific logic operation defined in both `.lib` and equivalent Verilog model.

![Screenshot 2025-07-10 123504](https://github.com/user-attachments/assets/6296668e-a456-456d-a440-16901512921d)

* You can view the **Verilog model** of the library using:

  ```bash
  :sp ../my_lib/verilog_model/sky130_fd_sc_hd.v
  ```

![Screenshot 2025-07-10 123718](https://github.com/user-attachments/assets/d68fcb2b-ca2d-4ce1-89ec-ae044a519da1)

* Since there are 5 inputs, and each can be 0 or 1:

  * Total possible input combinations = 2⁵ = **32**
  * The `.lib` includes **leakage power** data for **every combination**.

![Screenshot 2025-07-10 123819](https://github.com/user-attachments/assets/0f349e96-2b9e-48b8-a8a2-7c610fd18b1f)

---

### **5. Key Information Inside Each Cell Block**

Each cell definition includes:

| Parameter           | Description                                                              |
| ------------------- | ------------------------------------------------------------------------ |
| `area`              | Physical area of the cell (in square microns)                            |
| `pin`               | Definition block for each input/output port                              |
| `input_capacitance` | Intrinsic capacitance of the input pin                                   |
| `power`             | Power consumption info: internal power, leakage, dynamic                 |
| `timing`            | Delay, transition time, and slope-related timing information             |
| `function`          | Boolean logic function implemented by the cell                           |
| `related_pin`       | Specifies which other pin affects timing of a given pin (for setup/hold) |

![Screenshot 2025-07-10 124150](https://github.com/user-attachments/assets/45b75459-6780-4cd6-8089-39c057e4989a)

![Screenshot 2025-07-10 124248](https://github.com/user-attachments/assets/3de573fb-476b-4e52-a604-5c662b47b56b)

---

### **6. Importance in Synthesis and Timing**

The data in the `.lib` file helps the synthesis tool:

* Estimate **propagation delays**
* Analyze **power** and **leakage**
* Select the **most optimal variant** of a cell based on constraints
* Ensure that designs meet **setup**, **hold**, and **clock period** requirements

---
### SKY130RTL D2SK1 L2 Lab4 Introduction to dot Lib part3
---
Here is a structured explanation for **Example 2** on analyzing a smaller gate (AND gate) from the standard cell library. This version is formatted cleanly for use in reports, lab manuals, or documentation:

---

### **Example 2: Understanding a Simple Gate – AND Gate**

![Screenshot 2025-07-10 125526](https://github.com/user-attachments/assets/9bd03fb9-e2b0-4fcd-acda-adc65f037fa8)

#### **Cell Under Study: `sky130_fd_sc_hd__and2_0`**

![Screenshot 2025-07-10 125955](https://github.com/user-attachments/assets/f24be0a0-75cc-439a-b81e-ceadd350cb7d)

This is a **2-input AND gate** from the Sky130 standard cell library.

* **Name**: `sky130_fd_sc_hd__and2_0`
* **Function**: Performs logical AND on two inputs
* **Inputs**: A, B
* **Output**: Y
* **Input Combinations**: Since it has 2 inputs, total possible combinations = 2² = **4**

---

### **Verilog Model**

The behavior of this cell can be viewed by opening the Verilog model file:

```bash
:sp ../my_lib/verilog_model/sky130_fd_sc_hd.v
```
![Screenshot 2025-07-10 131129](https://github.com/user-attachments/assets/9d7f18e9-6af0-4fa1-b318-96f5b38fea76)

In the Verilog model, you’ll find something like:

![Screenshot 2025-07-10 131409](https://github.com/user-attachments/assets/3d0050b1-dfe1-4837-9aa0-6ba5b1069818)

---
### **Area Analysis**

To compare the area of two AND gate variants (`and2_0` vs `and2_1`), open the `.lib` file and locate the corresponding `cell` blocks.

> **Note:**
> To split the GVim window vertically for side-by-side viewing, use the command:
>
> ```
> :vsp
> ```
>
> This is useful for comparing two cells (e.g., `and2_0` and `and2_1`) in the same `.lib` file.

![Screenshot 2025-07-10 131816](https://github.com/user-attachments/assets/55cd3433-5d67-48d7-a0e1-a55507ed7250)

Inside the `.lib` file (`sky130_fd_sc_hd__tt_025C_1v80.lib`), search for:

```liberty
cell (sky130_fd_sc_hd__and2_0) {
    area : <value>;
    ...
}

cell (sky130_fd_sc_hd__and2_1) {
    area : <larger value>;
    ...
}
```
![Screenshot 2025-07-10 132314](https://github.com/user-attachments/assets/56b2f260-9359-4cd8-add5-23be44c5422e)

This shows that:

* `and2_1` has a **larger area** than `and2_0`.
* The larger area implies **wider transistors** are used in `and2_1`.
* **Wider transistors** can **source/sink more current**, leading to **faster switching**, but they occupy more silicon area and consume more power.

#### **Comparison: `and2_0` vs `and2_1`**

| Cell Name                 | Area (μm²) | Inference                    |
| ------------------------- | ---------- | ---------------------------- |
| `sky130_fd_sc_hd__and2_0` | Smaller    | Narrower transistors, slower |
| `sky130_fd_sc_hd__and2_1` | Larger     | Wider transistors, faster    |

This implies:

* **Higher drive strength versions** (like `_1`, `_2`) use **wider transistors**.
* Wider transistors can **charge/discharge load capacitance faster**, resulting in **lower delay**.
* However, they **consume more area** and often more **power**.

---

### **Conclusion**

By comparing `and2_0` and `and2_1` in the `.lib` file:

* You observe the **trade-off between area and performance**.
* Larger cells = **faster**, but **costlier** in silicon area.
* Synthesis tools must choose the **right variant** based on timing, area, and power constraints.

---
## Hierarchical vs Flat Synthesis
---
### SKY130RTL D2SK2 L1 Lab05 Hier synthesis flat synthesis part1
---
### **What is Hierarchical vs. Flat Synthesis?**

In digital design, a system can be built using **multiple submodules**. The way these are handled during synthesis can follow either a **hierarchical** or **flat** approach.

#### **Hierarchical Synthesis**

* In **hierarchical synthesis**, the **submodules are preserved** as independent entities during synthesis.
* Each module is synthesized separately, and then connected at the top level.
* **Benefits**:

  * Faster synthesis for large designs
  * Useful for modular debugging and reuse
* **Drawbacks**:

  * Limited global optimization across module boundaries

#### **Flat Synthesis**

* In **flat synthesis**, all submodules are **inlined into the top-level module**, forming a single flattened netlist.
* This allows the synthesizer to perform **global optimizations**.
* **Benefits**:

  * Better optimization for area, timing, and power
* **Drawbacks**:

  * More memory and time-consuming
  * Harder to trace logic back to original modules

---

### **Example Design: `multiple_modules.v`**

This file is located in the `verilog_files` directory and defines a small hierarchical design using two submodules.

#### **Code**

![Screenshot 2025-07-10 140014](https://github.com/user-attachments/assets/b1150e7a-e510-463b-a751-c58587950dca)

```verilog
// OR gate module
module sub_module2 (input a, input b, output y);
  assign y = a | b;
endmodule

// AND gate module
module sub_module1 (input a, input b, output y);
  assign y = a & b;
endmodule

// Top-level module using two submodules
module multiple_modules (input a, input b, input c, output y);
  wire net1;

  sub_module1 u1 (.a(a), .b(b), .y(net1));  // net1 = a & b
  sub_module2 u2 (.a(net1), .b(c), .y(y));  // y = net1 | c => y = (a & b) | c

endmodule
```
![Screenshot 2025-07-10 135806](https://github.com/user-attachments/assets/246af06f-d3e2-4162-82a8-aa1b4988be72)

### **Synthesis of `multiple_modules.v`**

Let’s now synthesize the `multiple_modules.v` file.

![Screenshot 2025-07-10 140800](https://github.com/user-attachments/assets/c255ac8a-9774-44e3-9264-f2a216745a5b)

![Screenshot 2025-07-10 141008](https://github.com/user-attachments/assets/0882e82d-f664-4f39-affa-84bed7c929c7)

![Screenshot 2025-07-10 141112](https://github.com/user-attachments/assets/b912493e-8afe-4f09-bc69-e2a7adf2619e)

This design includes two submodules:

* `sub_module1` implements an **AND** gate
* `sub_module2` implements an **OR** gate

The top-level module, `multiple_modules`, instantiates:

* One instance of `sub_module1` (named `u1`)
* One instance of `sub_module2` (named `u2`)

The report shows:

* `sub_module1` contains **one AND gate**
* `sub_module2` contains **one OR gate**
* The top module contains **one instance of each submodule**

Overall, the entire design consists of:

* **One AND gate**
* **One OR gate**

Now, Linkimg the design to the library
In Yosys, this is done using the following command:

```yosys
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
![Screenshot 2025-07-10 142103](https://github.com/user-attachments/assets/f730f208-60a0-49df-b9b9-fb43767f1dd9)

### **Visualizing the Synthesized Design: Hierarchical View**

After synthesis and linking, use the following Yosys command to view the synthesized logic:

```yosys
show multiple_modules
```
![Screenshot 2025-07-10 142511](https://github.com/user-attachments/assets/8aa2017e-3d17-4e3b-b29b-9ca131fc7192)

This command opens a graphical representation of the design.

---

### **What Do You See?**

![Screenshot 2025-07-10 142551](https://github.com/user-attachments/assets/da2cc977-5573-4381-816b-8ee66d8c60af)

Instead of seeing a logic-level **block diagram** composed of **AND** and **OR** gates, the view shows two **instantiations**:

* `u1`: Instance of `sub_module1`
* `u2`: Instance of `sub_module2`

These are preserved **as separate blocks**, not broken down into their internal logic (AND/OR).

---

### **Why Does This Happen?**

This is an example of a **hierarchical design**.

* The synthesis has preserved the **module hierarchy**.
* The submodules (`sub_module1` and `sub_module2`) are shown as **black boxes** or **instances** inside the top module.
* You don’t see the gates (like AND, OR) because they are **inside the submodules**, and those were **not flattened**.

---

### **What We Expected vs. What We See**

| Expectation                     | Observation                       |
| ------------------------------- | --------------------------------- |
| AND and OR gates shown directly | Only u1 and u2 instances visible  |
| Flat gate-level logic diagram   | Hierarchical module-level diagram |

This highlights the **difference between flat and hierarchical synthesis**.

* **Flat synthesis**: Would have shown individual AND and OR gates.
* **Hierarchical synthesis**: Keeps module boundaries intact, and shows only instances like `u1` and `u2`.

### **Writing the Netlist**

Now let’s write the netlist using the following command:

```yosys
write_verilog -noattr multiple_modules_hier.v
```
![Screenshot 2025-07-10 152824](https://github.com/user-attachments/assets/b00b201f-f9ab-4ccc-8dd1-c5bf18f9a2f4)

This generates a netlist file named `multiple_modules_hier.v` without additional attributes.

![Screenshot 2025-07-10 152924](https://github.com/user-attachments/assets/4fd2f847-9e64-4453-9aee-a9b42a7ddc60)

When you open the file, you’ll observe that `sub_module1` and `sub_module2` are preserved as **separate modules** in the netlist.

![Screenshot 2025-07-10 153224](https://github.com/user-attachments/assets/74881faf-3c39-41fb-8ae5-2007463ba273)

![Screenshot 2025-07-10 153239](https://github.com/user-attachments/assets/d0108a90-5b8c-46b4-bda1-d8b1e1855793)

![Screenshot 2025-07-10 153256](https://github.com/user-attachments/assets/cd43a2c2-62d7-4eba-a0db-7255c426612b)

### **Observation from the Generated Netlist**

When the netlist was generated by the instructor, the structure of `sub_module2` appeared different from a straightforward OR gate implementation. It resembled something like the following:

![Screenshot 2025-07-10 154710](https://github.com/user-attachments/assets/841ef486-a448-4cdd-833e-b002c9af001b)

Instead of directly using an **OR gate**, the synthesis tool generated logic using **inverters and a NAND gate**, effectively implementing a **bubbled NAND** (DeMorgan equivalent of an OR gate).

### **Why Did the Synthesis Tool Do This?**

The tool chose this structure not by accident, but as an **optimization based on CMOS design principles**.

#### **CMOS Gate Implementation Basics:**

* **NAND gates** are implemented using **stacked NMOS transistors**, which switch faster and consume less area.
* **NOR gates** are implemented using **stacked PMOS transistors**, which are **slower** and **larger** due to the **poor mobility of holes in PMOS**.

#### **Key Reason:**

> **PMOS transistors have lower mobility than NMOS**, so a stack of PMOS (as in a NOR gate) results in **larger area and slower switching**.

To avoid this:

* The synthesis tool avoids direct NOR gates
* Instead, it may use **NAND + Inverters** (i.e., a bubbled NAND structure) to implement the same logic function **more efficiently** in silicon.

### **Conclusion**

Even though the RTL defines `sub_module2` as an OR gate:

```verilog
assign y = a | b;
```

The synthesis tool rewrites this into a form better suited for CMOS implementation — one that:

* Uses **fewer or smaller PMOS transistors**
* Is **faster and more area-efficient**
* Maintains the exact same logical behavior

This is a common optimization done automatically by the synthesis engine during technology mapping.
---
### SKY130RTL D2SK2 L2 Lab05 Hier synthesis flat synthesis part2
---
### **Synthesis Behavior**

* If you synthesize this design **hierarchically**, `sub_module1` and `sub_module2` will appear as **separate blocks** in the netlist.
* If you synthesize it **flat**, the synthesis tool will **merge** all logic into the `multiple_modules` block and eliminate submodule boundaries.

### **Flattening the Design**

To flatten the design and remove module hierarchies, use the following command in Yosys:

```yosys
flatten
write_verilog -noattr multiple_modules_flat.v
```
![Screenshot 2025-07-10 155854](https://github.com/user-attachments/assets/aaeb6403-9637-484d-8753-6539b876739c)

This generates a **flattened netlist** named `multiple_modules_flat.v`.

---

### **Comparison with Hierarchical Netlist**

![Screenshot 2025-07-10 160154](https://github.com/user-attachments/assets/301c0095-2e48-4f43-ba45-4f338aea6fab)

* In the **hierarchical netlist**, the definitions of `sub_module1` and `sub_module2` are **preserved as separate modules**.
* In the **flattened netlist**, the **hierarchy is removed**.

  * The logic inside the submodules is **inlined** into the top-level module.
  * You directly see the **AND** and **OR** gate instantiations within `multiple_modules`.

![Screenshot 2025-07-10 160427](https://github.com/user-attachments/assets/2dace79d-f0c1-41c2-bf16-4638393dbcb8)

![Screenshot 2025-07-10 160246](https://github.com/user-attachments/assets/f4402877-7346-4655-a41a-31982256573e)

use command show to see the graphyical representation

```yosys
show
```
![Screenshot 2025-07-10 161512](https://github.com/user-attachments/assets/1dbf7f23-dbfd-4e28-a565-6736858ae9d5)

---

### **Conclusion**

Flattening simplifies the structure for downstream tools and allows better optimization, but it also removes modular boundaries, making the design harder to interpret manually.

---

### **Submodule-Level Synthesis**

Let’s now perform **synthesis at the submodule level**, taking `sub_module1` (instance `u1`) as an example.

#### **Yosys Commands:**

```yosys
read_liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_modules.v
synth -top sub_module1
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
```
![Screenshot 2025-07-10 162957](https://github.com/user-attachments/assets/b79a96c2-df3b-4269-9438-6c37dd565e1b)

![Screenshot 2025-07-10 163123](https://github.com/user-attachments/assets/07edd3cf-00ef-46de-9ec6-4465440bfd08)

![Screenshot 2025-07-10 163216](https://github.com/user-attachments/assets/7c78eeea-f202-41cb-9852-51b393ee5558)

![Screenshot 2025-07-10 163255](https://github.com/user-attachments/assets/14eaa288-2e57-420e-a0a4-a722261ae945)

---

### **What Do We See?**

Since we’ve explicitly specified `sub_module1` as the top module, Yosys synthesizes **only this module**, which is a simple **AND gate**.

* The visualization (`show`) displays just the **AND gate logic**.
* You will **not see `sub_module2`** or the top-level module `multiple_modules`.

---

### **Why Perform Submodule-Level Synthesis?**

Submodule-level synthesis is useful in several scenarios:

#### **1. Reuse of Repeated Logic**

* Consider a design where the top-level module contains **six instances of a multiplier**.
* Instead of synthesizing the multiplier logic **six times**, we can:

  * Synthesize the multiplier module **once**
  * **Reuse** that synthesized instance multiple times in the top module
* This improves **efficiency**, **reduces redundancy**, and saves **time and resources**.

#### **2. Divide and Conquer Approach**

* For **large or complex designs**, it's more practical to:

  * Synthesize individual submodules independently
  * Then integrate them into the full system
* This approach is scalable and simplifies **debugging**, **timing analysis**, and **modular development**.

---

### **Conclusion**

Submodule-level synthesis allows:

* **Efficient handling** of repeated instances
* Easier **modular design and optimization**
* A scalable method for managing **large-scale digital systems**

---
##
---
###
---

### **Given:**

Expression:

```
Y = (A & B) | C
```

### **Gate Delays:**

* AND gate = **2 ns**
* OR gate = **1 ns**

---

### **Input Transitions at t = 0 ns:**

| Signal | Transition    |
| ------ | ------------- |
| A      | 0 → 1 at 0 ns |
| B      | 0 → 1 at 0 ns |
| C      | 1 → 0 at 0 ns |

---

### **Initial Values (before 0 ns):**

* A = 0
* B = 0
* C = 1
  → (A & B) = 0
  → Y = 0 | 1 = **1**

Now let’s analyze what happens **after time = 0 ns**.

---

### **Step-by-Step Timing:**

#### **Time = 0 ns**

* A and B start transitioning from 0 → 1
* C starts transitioning from 1 → 0

#### **Time = 1 ns**

* OR gate sees C = 0
  → It sees (A & B) = **still 0** (AND hasn't produced output yet — 2 ns delay)
  → OR gate evaluates: `0 | 0 = 0`
  → **Y falls to 0** → **glitch**

#### **Time = 2 ns**

* AND gate output becomes 1 (A=1, B=1)
* OR gate sees: `1 | 0 = 1`
  → Y returns to 1

---

### **Waveform**

![image](https://github.com/user-attachments/assets/287b99d2-b2ae-46ce-a503-28aa9ac7b920)

---

### **Conclusion:**

* Y was initially **1**
* Due to all signals changing simultaneously, the OR gate **briefly saw both inputs as 0** at 1 ns:

  * AND gate hadn't responded yet
  * C had already dropped to 0
* So **Y glitched** to 0, then returned to 1 after AND gate output arrived
* This is a **Static-1 hazard**, caused by **unbalanced path delays**

---

### **Why We Need a Flip-Flop in Digital Circuits**

In a **purely combinational circuit**, outputs respond directly to input changes — including glitches caused by signal delays. If there is no mechanism to control when outputs are sampled or updated, **glitches may propagate continuously**, preventing the output from ever settling. This is undesirable, especially in sequential digital systems.

---

### **Role of Flip-Flops**

To solve this problem, we introduce a **flip-flop** (typically a **D flip-flop**) — a **storage element** used to:

* **Capture and hold** the output of a combinational block
* **Restrict glitches** from propagating endlessly
* **Synchronize signal transitions** using a **clock edge**

The **D flip-flop updates its output only at a specific clock edge** (usually rising or falling), so:

* Even if the combinational logic is glitchy in between, the flip-flop **ignores** those changes
* It passes **only the final, stable value** to the next stage
* Thus, each stage in the circuit receives **stable inputs**, allowing the system to function reliably

---

### **Why Initialization Is Important**

If the **initial state** of a flip-flop is unknown (i.e., not set or reset), the output of the combinational logic **may evaluate incorrectly**, producing garbage values.

To avoid this:

* We **initialize** the flip-flop using a **reset** or **set** signal during startup
* This ensures the system starts from a **known, predictable state**

---
SKY130RTL D2SK3 L2 Why Flops and Flop coding styles part2
---
![WhatsApp Image 2025-07-12 at 19 07 29_9fdbf700](https://github.com/user-attachments/assets/543a755b-8899-45fe-b755-19e9146c9769)

![WhatsApp Image 2025-07-12 at 19 07 34_c758e502](https://github.com/user-attachments/assets/9265c24c-d36d-4ccc-a20e-c920d1046173)

![WhatsApp Image 2025-07-12 at 19 08 27_07462e6b](https://github.com/user-attachments/assets/10fe12ad-56d8-4694-ae1d-5ee622bcf00d)

---
### SKY130RTL D2SK3 L3 Lab flop synthesis simulations part1
---
Now lets simulate the following flops 
1) D FlipFlop with Asynchronous reset
2) D FlipFlop with Synchronous reset
3) D FlipFlop with Synchronous and Asynchronous reset
4) D FlipFlop with Asynchronous set

**1) D FlipFlop with Asynchronous reset**

<img width="2468" height="657" alt="Screenshot 2025-07-13 113250" src="https://github.com/user-attachments/assets/4b925fc8-c33b-4a61-8a35-faaae9858344" />

<img width="1531" height="1841" alt="Screenshot 2025-07-13 113344" src="https://github.com/user-attachments/assets/87e626f9-622f-446a-a2bb-756d769e7167" />

<img width="3838" height="2160" alt="Screenshot 2025-07-12 192545" src="https://github.com/user-attachments/assets/7f568421-7b4f-4b29-9b02-aa18e8f39465" />

Zoomed out waveform

<img width="3839" height="2159" alt="Screenshot 2025-07-12 192743" src="https://github.com/user-attachments/assets/6a8769d8-7a36-4282-8ca2-9ec1612007e5" />

Zooming at the point when reset changes from low to high

<img width="3839" height="2159" alt="Screenshot 2025-07-12 193027" src="https://github.com/user-attachments/assets/a0b06d49-72ec-4183-945d-3c2c39eede47" />

**2) D FlipFlop with Synchronous reset**

<img width="3075" height="591" alt="Screenshot 2025-07-13 113434" src="https://github.com/user-attachments/assets/b941fd73-e33b-4740-b05c-4da861c43bfb" />

<img width="1607" height="1617" alt="Screenshot 2025-07-13 113510" src="https://github.com/user-attachments/assets/fd59a134-d7b6-4225-95fa-4aee701c3d00" />

<img width="3838" height="2106" alt="Screenshot 2025-07-12 195332" src="https://github.com/user-attachments/assets/7a5b9b03-d367-4b54-bb5c-5d585e65f7eb" />

<img width="3838" height="2117" alt="Screenshot 2025-07-12 195852" src="https://github.com/user-attachments/assets/0277190a-6ed1-4939-8b17-eec084109245" />

<img width="3838" height="2160" alt="Screenshot 2025-07-12 195827" src="https://github.com/user-attachments/assets/0b63e386-56fc-43c8-9d71-673fd61c1a4b" />

**3) D FlipFlop with Synchronous and Asynchronous reset**

<img width="3340" height="670" alt="Screenshot 2025-07-13 113544" src="https://github.com/user-attachments/assets/6898f427-eef1-4c65-98d9-b30dc03d22e2" />

<img width="1760" height="1676" alt="Screenshot 2025-07-13 113624" src="https://github.com/user-attachments/assets/514cdab4-30d3-4c70-8359-c33bbe6d97fe" />

<img width="3838" height="2115" alt="Screenshot 2025-07-12 200247" src="https://github.com/user-attachments/assets/5b8a06e7-8593-4c84-ab5e-35fb73502564" />

<img width="3839" height="2119" alt="Screenshot 2025-07-12 200439" src="https://github.com/user-attachments/assets/1aa67ed3-0d37-43ad-bf9c-8b0cc78cff28" />

<img width="3839" height="2109" alt="Screenshot 2025-07-12 200550" src="https://github.com/user-attachments/assets/f68a6757-f7cd-4638-a6d7-e47125c42df0" />

<img width="3839" height="2114" alt="Screenshot 2025-07-12 201051" src="https://github.com/user-attachments/assets/bc43c50d-c700-401d-822d-ada4910fd15e" />

<img width="3839" height="2117" alt="Screenshot 2025-07-12 201122" src="https://github.com/user-attachments/assets/89bc27d5-1c87-46c2-920d-4f6f2c1216ac" />

**4) D FlipFlop with Asynchronous set**

<img width="2588" height="705" alt="Screenshot 2025-07-13 113700" src="https://github.com/user-attachments/assets/e49ecf70-45ec-4c57-999e-143490f427f1" />

<img width="1516" height="1616" alt="Screenshot 2025-07-13 113740" src="https://github.com/user-attachments/assets/762bf398-92db-4314-9daa-7a13a3195ac6" />

<img width="3838" height="2117" alt="Screenshot 2025-07-13 102619" src="https://github.com/user-attachments/assets/7ef519f8-8ec5-4a18-b372-f10ebb13f472" />

<img width="3838" height="2124" alt="Screenshot 2025-07-13 102732" src="https://github.com/user-attachments/assets/e88e694c-1b3f-45c5-81b1-e0c78c726900" />

<img width="3838" height="2151" alt="Screenshot 2025-07-13 102838" src="https://github.com/user-attachments/assets/49bacf1e-eb9c-46ed-b7cc-938f6ac6b1b6" />

<img width="3838" height="2115" alt="Screenshot 2025-07-13 103540" src="https://github.com/user-attachments/assets/c9f01b1a-979f-4065-a6dd-a7940cbfb6b8" />

---
### SKY130RTL D2SK3 L4 Lab flop synthesis simulations part2
---
Now let's synthesize the following D flipflops
1) D FlipFlop with Asynchronous reset
2) D FlipFlop with Synchronous reset
3) D FlipFlop with Synchronous and Asynchronous reset
4) D FlipFlop with Asynchronous set

### **1) D FlipFlop with Asynchronous reset**

**Why We Use `dfflibmap` in Synthesis Flow**

When performing logic synthesis using tools like **Yosys**, we typically use a standard cell library (`.lib` file) that contains both **combinational** and **sequential** cells (like D flip-flops). However, in many design flows, **flip-flops are provided in a separate library** from the main logic gates.

To handle this, we use the Yosys command:

```bash
dfflibmap -liberty ../lib/your_flipflop_library.lib
```

---
**What `dfflibmap` Does**

* It maps generic D flip-flop constructs (like `always @(posedge clk)` in RTL) to **specific standard cells** in the library.
* This is essential for **correct technology mapping** — otherwise, the tool may not know which flip-flop cell to use.
* It ensures **timing-aware synthesis** using the correct sequential elements.

---
**Typical Flow Including `dfflibmap`**

```bash
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog design.v
synth -top <top_module>
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
<img width="3838" height="2160" alt="Screenshot 2025-07-13 105556" src="https://github.com/user-attachments/assets/4e7d1d83-c8c9-4942-b8bc-863e49795d1e" />

<img width="3838" height="2110" alt="Screenshot 2025-07-13 110713" src="https://github.com/user-attachments/assets/0f6acf5a-fac9-4114-9edb-78b861526ab7" />

<img width="3838" height="2115" alt="Screenshot 2025-07-13 110824" src="https://github.com/user-attachments/assets/0ce6792d-545c-48dc-bd62-4254c6b4a9da" />

<img width="3838" height="2160" alt="Screenshot 2025-07-13 110938" src="https://github.com/user-attachments/assets/1984c97e-5658-46d7-83e4-6aabaa3f86fd" />

<img width="3838" height="2112" alt="Screenshot 2025-07-13 111120" src="https://github.com/user-attachments/assets/aa77cee2-4a2e-4ec1-a876-155920014233" />

<img width="3838" height="2121" alt="Screenshot 2025-07-13 111052" src="https://github.com/user-attachments/assets/125cdfae-6a0d-4f49-9a24-8e824de3fa56" />

**Why the Tool Inserted an Inverter**

In the Verilog code, the D flip-flop is written with an **active-high reset** condition:

```verilog
if (reset)
    q <= 0;
```

However, the standard cell library may only contain **flip-flops with active-low reset** functionality.

To resolve this mismatch, the synthesis tool automatically inserts an **inverter** in front of the reset signal. This converts the active-high reset logic used in the RTL to match the **active-low reset behavior** expected by the physical flip-flop cell in the library.

---

**Why `dfflibmap` is Important**

* Without `dfflibmap`, the flip-flop may **not be mapped** correctly to a physical cell.
* This can result in either:

  * **Synthesis failure**
  * Or an **incomplete netlist** (no physical representation for your DFF)

---

### **2) D FlipFlop with Synchronous reset**


### **3) D FlipFlop with Synchronous and Asynchronous reset**
### **4) D FlipFlop with Asynchronous set**

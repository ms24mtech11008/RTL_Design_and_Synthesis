# RTL_Design_and_Synthesis
## Table of contents
- [Day 1 - Introduction to Verilog RTL design and Synthesis](#Day-1---Introduction-to-Verilog-RTL-design-and-Synthesis)
 - [Introduction to open-source simulator iverilog](#Introduction-to-open-source-simulator-iverilog)
  - [SKY130RTL D1SK1 L1 Introduction to iverilog design test bench](#SKY130RTL-D1SK1-L1-Introduction-to-iverilog-design-test-bench)
 - [Labs using iverilog and gtkwave](#Labs-using-iverilog-and-gtkwave)
  - [SKY130RTL D1SK2 L1 Lab1 introduction to lab](#SKY130RTL-D1SK2-L1-Lab1-introduction-to-lab)
  - [SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1](#SKY130RTL-D1SK2-L2-Lab2-Introduction-iverilog-gtkwave-part1)
  - [SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2](#SKY130RTL-D1SK2-L3-Lab2-Introduction-iverilog-gtkwave-part2)
 - [Introduction to Yosys and Logic synthesis](#Introduction-to-Yosys-and-Logic-synthesis)
  - [SKY130RTL D1SK3 L1 Introduction to yosys](#SKY130RTL-D1SK3-L1-Introduction-to-yosys)
  - [SKY130RTL D1SK3 L2 introduction to logic synthesis part1](#SKY130RTL-D1SK3-L2-introduction-to-logic-synthesis-part1)


# Day 1 - Introduction to Verilog RTL design and Synthesis
## Introduction to open-source simulator iverilog
---
### SKY130RTL D1SK1 L1 Introduction to iverilog design test bench
---

A **simulator** is a tool used to verify the behavior of a design. In RTL design, the simulator checks whether the design adheres to the specifications by applying a set of input stimuli.

In this course, we are using **Icarus Verilog (iverilog)** as the simulation tool.

### What is a Design?

A **design** is the actual Verilog code or a set of Verilog modules that implement the intended functionality to meet the required specifications.

### What is a Test Bench?

A **test bench** is the setup used to apply input stimuli (test vectors) to the design in order to verify its functionality. It provides the inputs and checks the outputs of the design during simulation.

### How Does a Simulator Work?

The simulator monitors the input signals for any changes.

* When an input changes, the simulator evaluates and updates the outputs accordingly.
* If there is no change in the inputs, the outputs remain unchanged.
  The simulator is event-driven and responds only to input value changes.

### Design and Test Bench Setup

The design contains one or more **primary inputs** and **primary outputs**.
The **test bench** includes:

* A **stimulus generator** to apply input signals to the design.
* A **stimulus observer** to monitor and verify the outputs.

All these components together form the test bench environment.

**Note:** The test bench itself does not have any primary inputs or outputs. It operates entirely within the simulation environment to drive and observe the design.

![Screenshot 2025-07-09 130655](https://github.com/user-attachments/assets/c85f95a3-6840-47e1-9fe2-c673c71d2915)

Iverilog-based simulation flow:

The design and test bench are provided as inputs to iverilog. As mentioned earlier, the simulator monitors changes in input signals and updates the output accordingly. The output generated by the simulator is a `.vcd` file, which stands for Value Change Dump format.

To view this output waveform, we use **GTKWave**.

![Screenshot 2025-07-09 132236](https://github.com/user-attachments/assets/39f77655-dfcb-4376-a798-04ee26d51e25)

---
## Labs using iverilog and gtkwave
---
### SKY130RTL D1SK2 L1 Lab1 introduction to lab
---
### Toolflow and File Setup for Labs

We will now set up the necessary toolflow and file structure to run the labs.

#### Step 1: Create a Directory

Create a directory named `VLSI` and navigate into it:

```bash
mkdir VLSI
cd VLSI
````

#### Step 2: Clone the Required Repositories

Clone the following repositories from GitHub:

* **sky130RTLDesignAndSynthesisWorkshop**

```bash
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
```

* **vsdflow**

```bash
git clone https://github.com/kunalg123/vsdflow.git
```

After this, your directory structure should look like:

```
VLSI/
├── sky130RTLDesignAndSynthesisWorkshop/
└── vsdflow/
```

This completes the initial setup required for running the labs.

![Screenshot 2025-07-09 143022](https://github.com/user-attachments/assets/e5cceec9-36a3-498b-a280-3b4e9be97b39)

![Screenshot 2025-07-09 143738](https://github.com/user-attachments/assets/9b16df58-5cf3-4465-b7b4-6700127203ad)

The contents of sky130RTLDesignAndSynthesisWorkshop directory are shown below

![Screenshot 2025-07-09 144919](https://github.com/user-attachments/assets/2f697cc0-57fc-4b92-9117-602ef47dccdd)

The `lib` directory contains the standard cell library that we will use for synthesis.
The `verilog_model` directory contains the Verilog models of all the standard cells present in the `.lib` file.

![Screenshot 2025-07-09 145308](https://github.com/user-attachments/assets/34e65092-a36f-4a94-9ced-8a46ed362db3)

![Screenshot 2025-07-09 145557](https://github.com/user-attachments/assets/915a4bdd-e194-45c5-a634-aec0d4b11516)

The `verilog_files` folder contains all our lab experiments, including both the source files and the testbench files.

![Screenshot 2025-07-09 145515](https://github.com/user-attachments/assets/e37cadf1-25dd-4c3a-8d8a-15160cb84add)

---
### SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1
---

### Tool Installation

Install the following tools required to run the labs:

#### 1. Install **Icarus Verilog** (`iverilog`)

```bash
sudo apt-get install iverilog
```

#### 2. Install **GTKWave**

```bash
sudo apt-get install gtkwave
```

These tools will allow you to compile Verilog files and visualize waveform outputs.

![Screenshot 2025-07-09 150942](https://github.com/user-attachments/assets/0f30c5ee-21e3-45c4-ba69-a85477202f3a)

![Screenshot 2025-07-09 151053](https://github.com/user-attachments/assets/0864bae3-e7c2-40e7-8456-10f02e9ac3d3)

### Simulate the Design: `good_mux`

Follow the steps below to compile, simulate, and view the waveform for the `good_mux` design.

#### 1. Compile the Design and Testbench

```bash
iverilog good_mux.v tb_good_mux.v
```

#### 2. Run the Simulation

```bash
./a.out
```

This will generate a waveform file named `tb_good_mux.vcd`.

#### 3. View the Waveform

```bash
gtkwave tb_good_mux.vcd
```

The verilog code for the design good_mux.v is shown below

![Screenshot 2025-07-09 151517](https://github.com/user-attachments/assets/aab406e3-8420-4069-9ed0-23897d87bd9d)

The verilog code for the testbench tb_good_mux.v is shown below

![Screenshot 2025-07-09 151553](https://github.com/user-attachments/assets/30be7049-31fe-4892-9a11-b4509f56c16a)

results:

![Screenshot 2025-07-09 151737](https://github.com/user-attachments/assets/8c56832a-1d8c-454c-b89b-78cada20f947)

viewing the waveform 

![Screenshot 2025-07-09 151853](https://github.com/user-attachments/assets/7b132bcf-8e75-4842-a5b1-e519a5c157d0)

![Screenshot 2025-07-09 152147](https://github.com/user-attachments/assets/d208c04a-237f-44d9-b008-9e7926d5f996)

---
### SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2
---

### 1. `good_mux.v` (Design)

```verilog
module good_mux (input i0, input i1, input sel, output reg y);

  always @(*) begin
    if (sel)
      y = i1;
    else
      y = i0;
  end

endmodule
```

### Explanation:

* **Inputs**: `i0`, `i1`, and `sel` (all 1-bit signals)
* **Output**: `y` (register type, 1-bit)
* The `always @(*)` block watches all inputs.
* If `sel = 1`, then `y = i1`; else `y = i0`.
* This is a 2:1 multiplexer.

---

## 2.`tb_good_mux.v` (Testbench)

```verilog
`timescale 1ns / 1ps

module tb_good_mux;

  // Inputs
  reg i0, i1, sel;

  // Output
  wire y;

  // Instantiate the Unit Under Test (UUT)
  good_mux uut (
    .i0(i0),
    .i1(i1),
    .sel(sel),
    .y(y)
  );

  initial begin
    $dumpfile("tb_good_mux.vcd");
    $dumpvars(0, tb_good_mux);

    // Initialize Inputs
    sel = 0;
    i0 = 0;
    i1 = 0;

    // Run simulation for 300 ns
    #300 $finish;
  end

  // Toggle sel every 75 ns
  always #75 sel = ~sel;

  // Toggle i0 every 10 ns
  always #10 i0 = ~i0;

  // Toggle i1 every 55 ns
  always #55 i1 = ~i1;

endmodule
```

---

## Testbench Behavior:

* Simulation runs for 300 ns.
* `sel` toggles every 75 ns to switch between `i0` and `i1`.
* `i0` toggles every 10 ns.
* `i1` toggles every 55 ns.
* Output `y` follows `i0` or `i1` based on the value of `sel`.
* Waveform is dumped to `tb_good_mux.vcd` and can be viewed using GTKWave.

---
## Introduction to Yosys and Logic synthesis
---
### SKY130RTL D1SK3 L1 Introduction to yosys
---

## Introduction to Yosys

**Yosys** is the synthesizer tool used in this course. It is responsible for converting RTL (Register Transfer Level) code into a gate-level **netlist** using standard cells.

### Role of Synthesizer:

A synthesizer takes a digital RTL design and a standard cell library (`.lib` file) and generates a netlist that represents the circuit using gates and cells from the library.

### Yosys Synthesis Flow:

1. **Inputs to Yosys**:

   * The RTL design (`.v` file)
   * The standard cell library (`.lib` file)

![Screenshot 2025-07-09 155007](https://github.com/user-attachments/assets/a2b57e82-b6cb-489f-a5b2-fe5d23f89cf8)


2. **Yosys Commands**:

   * `read_verilog` – Reads the Verilog design file.
   * `read_liberty` – Reads the `.lib` file containing timing and cell information.
   * `write_verilog` – Writes out the synthesized netlist.

![Screenshot 2025-07-09 155111](https://github.com/user-attachments/assets/ecfeb932-9879-41b6-958a-39ed83652fe3)

3. **Output**:

   * A netlist file representing the design using standard cells from the `.lib` library.

### Netlist Verification:

To verify if the synthesis process was successful and functionally correct:

* Use the **same testbench** that was used for the original RTL simulation.
* Apply the synthesized **netlist** and the **testbench** to the simulator (**Icarus Verilog**).
* Generate the VCD (`.vcd`) file.
* Load the VCD file in **GTKWave** and compare the waveform output.

![Screenshot 2025-07-09 155345](https://github.com/user-attachments/assets/61b6d58e-e37e-4e12-b016-1ec309d89379)

### Important Notes:

* The stimulus in the testbench **must match** the one used during RTL simulation.
* The **primary inputs and outputs** of the netlist remain the same as the RTL design.
* Therefore, **the same testbench** can be reused for post-synthesis simulation.

![Screenshot 2025-07-09 155551](https://github.com/user-attachments/assets/fae00675-36ce-46d9-a14c-be5a60da2f5d)

---
### SKY130RTL D1SK3 L2 introduction to logic synthesis part1
---



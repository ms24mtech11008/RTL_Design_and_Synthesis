# RTL_Design_and_Synthesis
## Table of contents
- [Day 1 - Introduction to Verilog RTL design and Synthesis](#Day-1---Introduction-to-Verilog-RTL-design-and-Synthesis)
 - [Introduction to open-source simulator iverilog](#Introduction-to-open-source-simulator-iverilog)
  - [SKY130RTL D1SK1 L1 Introduction to iverilog design test bench](#SKY130RTL-D1SK1-L1-Introduction-to-iverilog-design-test-bench)
 - [Labs using iverilog and gtkwave](#Labs-using-iverilog-and-gtkwave)
  - [SKY130RTL D1SK2 L1 Lab1 introduction to lab](#SKY130RTL-D1SK2-L1-Lab1-introduction-to-lab)
  - [SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1](#SKY130RTL-D1SK2-L2-Lab2-Introduction-iverilog-gtkwave-part1)
  - [SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2](#SKY130RTL-D1SK2-L3-Lab2-Introduction-iverilog-gtkwave-part2)
 - [Introduction to Yosys and Logic synthesis](#Introduction-to-Yosys-and-Logic-synthesis)
  - [SKY130RTL D1SK3 L1 Introduction to yosys](#SKY130RTL-D1SK3-L1-Introduction-to-yosys)
  - [SKY130RTL D1SK3 L2 introduction to logic synthesis part1](#SKY130RTL-D1SK3-L2-introduction-to-logic-synthesis-part1)
  - [SKY130RTL D1SK3 L3 introduction to logic synthesis part2](#SKY130RTL-D1SK3-L3-introduction-to-logic-synthesis-part2)
 - [Labs using Yosys and Sky130 PDKs](#Labs-using-Yosys-and-Sky130-PDKs)
  - [SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1](#SKY130RTL-D1SK4-L1-Lab3-Yosys-1-good-mux-Part1)




# Day 1 - Introduction to Verilog RTL design and Synthesis
## Introduction to open-source simulator iverilog
---
### SKY130RTL D1SK1 L1 Introduction to iverilog design test bench
---

A **simulator** is a tool used to verify the behavior of a design. In RTL design, the simulator checks whether the design adheres to the specifications by applying a set of input stimuli.

In this course, we are using **Icarus Verilog (iverilog)** as the simulation tool.

### What is a Design?

A **design** is the actual Verilog code or a set of Verilog modules that implement the intended functionality to meet the required specifications.

### What is a Test Bench?

A **test bench** is the setup used to apply input stimuli (test vectors) to the design in order to verify its functionality. It provides the inputs and checks the outputs of the design during simulation.

### How Does a Simulator Work?

The simulator monitors the input signals for any changes.

* When an input changes, the simulator evaluates and updates the outputs accordingly.
* If there is no change in the inputs, the outputs remain unchanged.
  The simulator is event-driven and responds only to input value changes.

### Design and Test Bench Setup

The design contains one or more **primary inputs** and **primary outputs**.
The **test bench** includes:

* A **stimulus generator** to apply input signals to the design.
* A **stimulus observer** to monitor and verify the outputs.

All these components together form the test bench environment.

**Note:** The test bench itself does not have any primary inputs or outputs. It operates entirely within the simulation environment to drive and observe the design.

![Screenshot 2025-07-09 130655](https://github.com/user-attachments/assets/c85f95a3-6840-47e1-9fe2-c673c71d2915)

Iverilog-based simulation flow:

The design and test bench are provided as inputs to iverilog. As mentioned earlier, the simulator monitors changes in input signals and updates the output accordingly. The output generated by the simulator is a `.vcd` file, which stands for Value Change Dump format.

To view this output waveform, we use **GTKWave**.

![Screenshot 2025-07-09 132236](https://github.com/user-attachments/assets/39f77655-dfcb-4376-a798-04ee26d51e25)

---
## Labs using iverilog and gtkwave
---
### SKY130RTL D1SK2 L1 Lab1 introduction to lab
---
### Toolflow and File Setup for Labs

We will now set up the necessary toolflow and file structure to run the labs.

#### Step 1: Create a Directory

Create a directory named `VLSI` and navigate into it:

```bash
mkdir VLSI
cd VLSI
````

#### Step 2: Clone the Required Repositories

Clone the following repositories from GitHub:

* **sky130RTLDesignAndSynthesisWorkshop**

```bash
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
```

* **vsdflow**

```bash
git clone https://github.com/kunalg123/vsdflow.git
```

After this, your directory structure should look like:

```
VLSI/
├── sky130RTLDesignAndSynthesisWorkshop/
└── vsdflow/
```

This completes the initial setup required for running the labs.

![Screenshot 2025-07-09 143022](https://github.com/user-attachments/assets/e5cceec9-36a3-498b-a280-3b4e9be97b39)

![Screenshot 2025-07-09 143738](https://github.com/user-attachments/assets/9b16df58-5cf3-4465-b7b4-6700127203ad)

The contents of sky130RTLDesignAndSynthesisWorkshop directory are shown below

![Screenshot 2025-07-09 144919](https://github.com/user-attachments/assets/2f697cc0-57fc-4b92-9117-602ef47dccdd)

The `lib` directory contains the standard cell library that we will use for synthesis.
The `verilog_model` directory contains the Verilog models of all the standard cells present in the `.lib` file.

![Screenshot 2025-07-09 145308](https://github.com/user-attachments/assets/34e65092-a36f-4a94-9ced-8a46ed362db3)

![Screenshot 2025-07-09 145557](https://github.com/user-attachments/assets/915a4bdd-e194-45c5-a634-aec0d4b11516)

The `verilog_files` folder contains all our lab experiments, including both the source files and the testbench files.

![Screenshot 2025-07-09 145515](https://github.com/user-attachments/assets/e37cadf1-25dd-4c3a-8d8a-15160cb84add)

---
### SKY130RTL D1SK2 L2 Lab2 Introduction iverilog gtkwave part1
---

### Tool Installation

Install the following tools required to run the labs:

#### 1. Install **Icarus Verilog** (`iverilog`)

```bash
sudo apt-get install iverilog
```

#### 2. Install **GTKWave**

```bash
sudo apt-get install gtkwave
```

These tools will allow you to compile Verilog files and visualize waveform outputs.

![Screenshot 2025-07-09 150942](https://github.com/user-attachments/assets/0f30c5ee-21e3-45c4-ba69-a85477202f3a)

![Screenshot 2025-07-09 151053](https://github.com/user-attachments/assets/0864bae3-e7c2-40e7-8456-10f02e9ac3d3)

### Simulate the Design: `good_mux`

Follow the steps below to compile, simulate, and view the waveform for the `good_mux` design.

#### 1. Compile the Design and Testbench

```bash
iverilog good_mux.v tb_good_mux.v
```

#### 2. Run the Simulation

```bash
./a.out
```

This will generate a waveform file named `tb_good_mux.vcd`.

#### 3. View the Waveform

```bash
gtkwave tb_good_mux.vcd
```

The verilog code for the design good_mux.v is shown below

![Screenshot 2025-07-09 151517](https://github.com/user-attachments/assets/aab406e3-8420-4069-9ed0-23897d87bd9d)

The verilog code for the testbench tb_good_mux.v is shown below

![Screenshot 2025-07-09 151553](https://github.com/user-attachments/assets/30be7049-31fe-4892-9a11-b4509f56c16a)

results:

![Screenshot 2025-07-09 151737](https://github.com/user-attachments/assets/8c56832a-1d8c-454c-b89b-78cada20f947)

viewing the waveform 

![Screenshot 2025-07-09 151853](https://github.com/user-attachments/assets/7b132bcf-8e75-4842-a5b1-e519a5c157d0)

![Screenshot 2025-07-09 152147](https://github.com/user-attachments/assets/d208c04a-237f-44d9-b008-9e7926d5f996)

---
### SKY130RTL D1SK2 L3 Lab2 Introduction iverilog gtkwave part2
---

### 1. `good_mux.v` (Design)

```verilog
module good_mux (input i0, input i1, input sel, output reg y);

  always @(*) begin
    if (sel)
      y = i1;
    else
      y = i0;
  end

endmodule
```

### Explanation:

* **Inputs**: `i0`, `i1`, and `sel` (all 1-bit signals)
* **Output**: `y` (register type, 1-bit)
* The `always @(*)` block watches all inputs.
* If `sel = 1`, then `y = i1`; else `y = i0`.
* This is a 2:1 multiplexer.

---

## 2.`tb_good_mux.v` (Testbench)

```verilog
`timescale 1ns / 1ps

module tb_good_mux;

  // Inputs
  reg i0, i1, sel;

  // Output
  wire y;

  // Instantiate the Unit Under Test (UUT)
  good_mux uut (
    .i0(i0),
    .i1(i1),
    .sel(sel),
    .y(y)
  );

  initial begin
    $dumpfile("tb_good_mux.vcd");
    $dumpvars(0, tb_good_mux);

    // Initialize Inputs
    sel = 0;
    i0 = 0;
    i1 = 0;

    // Run simulation for 300 ns
    #300 $finish;
  end

  // Toggle sel every 75 ns
  always #75 sel = ~sel;

  // Toggle i0 every 10 ns
  always #10 i0 = ~i0;

  // Toggle i1 every 55 ns
  always #55 i1 = ~i1;

endmodule
```

---

## Testbench Behavior:

* Simulation runs for 300 ns.
* `sel` toggles every 75 ns to switch between `i0` and `i1`.
* `i0` toggles every 10 ns.
* `i1` toggles every 55 ns.
* Output `y` follows `i0` or `i1` based on the value of `sel`.
* Waveform is dumped to `tb_good_mux.vcd` and can be viewed using GTKWave.

---
## Introduction to Yosys and Logic synthesis
---
### SKY130RTL D1SK3 L1 Introduction to yosys
---

## Introduction to Yosys

**Yosys** is the synthesizer tool used in this course. It is responsible for converting RTL (Register Transfer Level) code into a gate-level **netlist** using standard cells.

### Role of Synthesizer:

A synthesizer takes a digital RTL design and a standard cell library (`.lib` file) and generates a netlist that represents the circuit using gates and cells from the library.

### Yosys Synthesis Flow:

1. **Inputs to Yosys**:

   * The RTL design (`.v` file)
   * The standard cell library (`.lib` file)

![Screenshot 2025-07-09 155007](https://github.com/user-attachments/assets/a2b57e82-b6cb-489f-a5b2-fe5d23f89cf8)


2. **Yosys Commands**:

   * `read_verilog` – Reads the Verilog design file.
   * `read_liberty` – Reads the `.lib` file containing timing and cell information.
   * `write_verilog` – Writes out the synthesized netlist.

![Screenshot 2025-07-09 155111](https://github.com/user-attachments/assets/ecfeb932-9879-41b6-958a-39ed83652fe3)

3. **Output**:

   * A netlist file representing the design using standard cells from the `.lib` library.

### Netlist Verification:

To verify if the synthesis process was successful and functionally correct:

* Use the **same testbench** that was used for the original RTL simulation.
* Apply the synthesized **netlist** and the **testbench** to the simulator (**Icarus Verilog**).
* Generate the VCD (`.vcd`) file.
* Load the VCD file in **GTKWave** and compare the waveform output.

![Screenshot 2025-07-09 155345](https://github.com/user-attachments/assets/61b6d58e-e37e-4e12-b016-1ec309d89379)

### Important Notes:

* The stimulus in the testbench **must match** the one used during RTL simulation.
* The **primary inputs and outputs** of the netlist remain the same as the RTL design.
* Therefore, **the same testbench** can be reused for post-synthesis simulation.

![Screenshot 2025-07-09 155551](https://github.com/user-attachments/assets/fae00675-36ce-46d9-a14c-be5a60da2f5d)

---
### SKY130RTL D1SK3 L2 introduction to logic synthesis part1
---

### **Logic Synthesis Overview**

#### **1. RTL Design**

* RTL (Register Transfer Level) design is the **behavioral representation** of a digital system based on its required specification.
* It defines how data moves between registers and how operations are performed on that data.

![Screenshot 2025-07-10 093911](https://github.com/user-attachments/assets/14da95b2-b608-4591-9b49-6265b82af104)

![Screenshot 2025-07-10 093941](https://github.com/user-attachments/assets/97dbaded-68ba-4c5a-a742-81c2c2251a0c)

#### **2. What is Logic Synthesis?**

* Logic synthesis is the **process of converting RTL code into a digital logic circuit**.
* This involves translating behavioral descriptions into a network of logic gates.
* The transition from RTL to gate-level design is called **synthesis**.
* The final output of this process is a **netlist**, which describes the gates and their interconnections.

#### **3. Inputs and Outputs of Synthesis**

* **Inputs:**

  * RTL Design (written in Verilog or VHDL)
  * Technology Library (`.lib` file)
* **Output:**

  * Gate-level netlist (`.v` file)

![Screenshot 2025-07-10 094007](https://github.com/user-attachments/assets/cd388e51-8760-4ff2-9dcc-bbf54b26d40c)

#### **4. What is a `.lib` File?**

* A `.lib` file is a **collection of logic cells** provided by a standard cell library.
* It includes basic gates like **AND, OR, NOT**, and their **variants**:

  * Different **input configurations** (e.g., 2-input OR, 3-input OR)
  * Different **speed-power tradeoffs** (e.g., **slow**, **medium**, **fast** cells)

![Screenshot 2025-07-10 094022](https://github.com/user-attachments/assets/a81e341a-c57e-4682-8bab-8d948ff7abf7)

#### **5. Why Different Flavours of Gates?**

* The **combinational delay** in a logic path directly affects the **maximum speed** of a digital circuit.

![Screenshot 2025-07-10 094036](https://github.com/user-attachments/assets/e0f4f50a-053c-40fc-9b0f-62439c696b37)

* The clock cycle must account for:

  ```
  Tclk > Tcq_A + Tcomb + Tsetup_B
  ```

  * **Tcq\_A** = Clock-to-Q delay of DFF A
  * **Tcomb** = Delay of the combinational logic
  * **Tsetup\_B** = Setup time of DFF B

* To **minimize Tcomb**, we use **faster cells** from the `.lib` file.

* This helps reduce the required **clock period (Tclk)** and hence **increase the operating frequency**.

#### **6. Maximum Clock Frequency**

* The **minimum clock period** determines the **maximum frequency**:

  ```
  fclk(max) = 1 / Tclk(min)
  ```

![Screenshot 2025-07-10 094117](https://github.com/user-attachments/assets/e531047d-079a-4be1-bd90-bbcd3cefbbfe)

---
### SKY130RTL D1SK3 L3 introduction to logic synthesis part2
---

### **Are Faster Cells Sufficient?**

At first glance, it might seem that using only **faster cells** is the key to achieving **maximum performance**. After all, higher clock speeds typically mean better performance. But this leads us to an important question:

> If faster cells minimize delay, **why are slower cells needed at all?**

---

### **Why Do We Need Slow Cells?**

To meet **timing constraints**, both **setup** and **hold** times must be satisfied:

* For **setup time** (performance constraint), we want the data to arrive *before* the clock edge.
* For **hold time** (reliability constraint), we want the data to **stay stable briefly after** the clock edge.

![Screenshot 2025-07-10 095024](https://github.com/user-attachments/assets/66e3dea3-ce07-4e42-b216-b52dd5cd7e4c)

If the combinational delay is **too short**, we may violate **hold time**:

```
Thold_B < Tcq_A + Tcomb
```

So:

* We need **faster cells** to **reduce Tcomb** and meet setup timing.
* We need **slower cells** to **increase Tcomb** and avoid hold time violations.

The `.lib` file includes all these different **cell variants** to allow flexibility in achieving the correct balance.

---

### **Understanding Hold Time**

* **Hold time** of a flip-flop is the **minimum time** after the clock edge during which data **must remain stable**.
* If the input to flip-flop B changes **too quickly**, it might capture the **wrong data**.
* Thus, **slower cells** can intentionally **increase delay** to help meet the hold constraint.

---

### **Faster vs. Slower Cells**

* The **load** in a digital logic circuit is essentially a **capacitance**.
* The **faster** we can **charge/discharge** this load, the **lower** the propagation delay.

| Parameter        | Faster Cells          | Slower Cells              |
| ---------------- | --------------------- | ------------------------- |
| Transistor Width | Wider (more current)  | Narrower (less current)   |
| Delay            | Lower                 | Higher                    |
| Area             | Larger                | Smaller                   |
| Power            | Higher                | Lower                     |
| Use Case         | Improves setup timing | Helps fix hold violations |

---

### **Trade-Offs: Speed vs. Area/Power**

Faster cells offer performance benefits but come at a **cost**:

* **More area**
* **More power consumption**
* **Greater risk of hold time violations**

Slower cells are:

* **Power-efficient**
* **Area-efficient**
* **Useful in preventing hold violations**

Hence, **faster cells are not always sufficient or ideal**.

---

### **Selection of Cells: Synthesizer Guidance**

The **synthesis tool** decides which cells to use during logic synthesis. However, we must **guide** it to choose an **optimal mix** of fast and slow cells.

* **Too many fast cells** → High power, large area, potential hold issues.
* **Too many slow cells** → Fails to meet timing/performance goals.

This guidance is provided using **constraints**:

* Timing constraints (clock period, setup/hold margin)
* Area and power constraints
* Design objectives and priorities

---

### **Conclusion**

The process of synthesis is not just about making the circuit work—it's about making it work **efficiently**. The selection between faster and slower cells is a **critical design decision**, and synthesis tools use **constraints** to make this trade-off in a balanced way.

![Screenshot 2025-07-10 095118](https://github.com/user-attachments/assets/02fc26c7-9db8-4d52-8278-0edab170a5ef)

---
## Labs using Yosys and Sky130 PDKs
---
### SKY130RTL D1SK4 L1 Lab3 Yosys 1 good mux Part1
---

### **Introduction to Synthesizer: Yosys**

**Yosys** is an open-source synthesis tool used for converting RTL code into a gate-level netlist using a given standard cell library.

#### **Steps to Invoke and Use Yosys**

1. **Start Yosys**

   * Open a terminal and navigate to the working directory:

     ```bash
     cd verilog_files
     ```
   * Invoke the tool by typing:

     ```bash
     yosys
     ```

---

#### **1. Read the Standard Cell Library**

Before synthesis, the tool must understand the available logic cells. This is done by reading the `.lib` file:

```yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```

---

#### **2. Read the Verilog Design**

Next, import the RTL design (example: a multiplexer design named `good_mux.v`):

```yosys
read_verilog good_mux.v
```

![Screenshot 2025-07-10 101837](https://github.com/user-attachments/assets/ee6362bf-f4a4-479a-aebf-9e94cdc53062)

---

#### **3. Perform Synthesis**

Specify the top module of the design:

```yosys
synth -top good_mux
```
![Screenshot 2025-07-10 101929](https://github.com/user-attachments/assets/0c1476d1-7ab7-49a9-9289-118e98a896c4)

This step translates the RTL to a gate-level representation using generic gates.

![Screenshot 2025-07-10 101957](https://github.com/user-attachments/assets/50c26202-08bc-45db-8e04-508c9e3238a2)

---

#### **4. Technology Mapping**

Map the synthesized design to standard cells defined in the `.lib` file:

```yosys
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
![Screenshot 2025-07-10 102113](https://github.com/user-attachments/assets/7c8b46da-a69b-4e00-ae1f-1abdd597ce5f)

At this stage, the synthesis is complete and the result is a netlist using specific standard cells.

---

#### **5. Analyze the Output**

![Screenshot 2025-07-10 102151](https://github.com/user-attachments/assets/d2a1e221-0bfd-468e-9298-97eb9467711e)

* Compare the netlist with the original `good_mux.v`.
* **Note:**

  * The output netlist will not include internal signals.
  * Only **3 inputs** and **1 output** are visible (as in the original RTL).
  * The following **standard cells** are used:
mux2_1

---

#### **6. Visualize the Logic**

To view a graphical representation of the synthesized logic, use the `show` command:

```yosys
show
```

![Screenshot 2025-07-10 102641](https://github.com/user-attachments/assets/ac6efe5e-b198-49cc-a005-fffeb38689a3)

This launches a viewer that displays the gate-level circuit as derived from the RTL.

![Screenshot 2025-07-10 102709](https://github.com/user-attachments/assets/472d982b-6b1f-41d2-82fb-cbb8a053e5bf)

---


